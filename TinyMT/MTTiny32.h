#pragma once

// Typedefs used by this class:
typedef unsigned __int32 uint32;
typedef signed __int32 int32;

class TinyMT32
{
   /*
   * @file MTTiny32.h - implements the Tiny Mersenne Twister.  Very fast quality rng.
   * @brief Tiny Mersenne Twister - only 127 bit internal state
   * @OriginalAuthor Mutsuo Saito (Hiroshima University)
   * @OriginalAuthor Makoto Matsumoto (University of Tokyo)
   * Copyright (C) 2011 Mutsuo Saito, Makoto Matsumoto,
   * Hiroshima University and The University of Tokyo.
   * All rights reserved.
   * VC++ cpp implementation by Bob Bryan on 4/23/2012:
   * 1. Made the class retain state .vs. passing in the state each time a ran number is needed.
   * 2. Added a method to fill an array with random bytes - see GetRandBytes().
   * 3. Replaced globals with class vars.
   * 4. Renamed methods, constants and types to something easier to remember.
   * 5. Moved the private methods to the private section.
   * 6. Cleaned up some comments.
   * 7. Made the MT32State struct private.  Constructor now inits the object, but the Init method can
   *    still be called to re-init the object to a different seed so that constant creating / deleting
   *    of this object won't fragment memory.
   * 8. Removed the following methods:
   *    1. PeriodCertification - was not doing anything useful.
   *    2. Redundant floating point methods.
   *    3. Conversion functions that the above methods call.
   *
   * The 3-clause BSD License is applied to this software, see LICENSE.txt
   */
public:

   TinyMT32(uint32 Seed, uint32 Mat1, uint32 Mat2, uint32 TMat)
   {
      // Constructor - used to init the object.
      // Seed - used to seed the rng, best if obtained randomly.
      // Mat1, Mat2, & TMat are also used to seed the rng.  These values are generated by
      // the TinyMTDC utility app.  Only values generated from this program should be used.
      Init(Seed, Mat1, Mat2, TMat);
   }

   virtual ~TinyMT32(void) {}

   __inline uint32 GetRandInt()
   {
      // This function outputs 32-bit prng unsigned integer from the internal state.
      // Return value is a 32-bit unsigned integer r (0 <= r < 2^32).
       GetNextState();
       return GetNextRand();
   }

   void GetRandBytes(void *pBytes, int NumBytes);

   __inline float GetRandFloat()
   {
   // This function outputs floating point number from internal state.
   // This function is implemented using multiplying by 1 / 2^32.
   // Floating point multiplication is faster than using union trick in my Intel CPU.
   // Return value i a floating point number r (0.0 <= r < 1.0)
       GetNextState();
       return (float)(GetNextRand() * TinyMT32_Mul);
   }

   void Init(uint32 Seed, uint32 Mat1, uint32 Mat2, uint32 TMat);

   void InitByArray(uint32 Mat1, uint32 Mat2, uint32 TMat, uint32 init_key[], int key_length);

private:

   static const int TinyMT32_MExp = 127;
   static const int TinyMT32_SH0 = 1;
   static const int TinyMT32_SH1 = 10;
   static const int TinyMT32_SH8 = 8;
   static const unsigned int TinyMT32_Mask = 0x7fffffff;
   static const int MinLoop = 8;
   static const int PreLoop = 8;
   static const int NumBytesInInt = 4;
   static double TinyMT32_Mul;

   struct MT32State
   {
      //
      // Holds the internal state vector and parameters used by the rng.
      //
      uint32 Status[4];
      uint32 Mat1;
      uint32 Mat2;
      uint32 TMat;
   };

   MT32State MTState; // Holds the state.

   __inline uint32 GetNextRand()
   {
      // This function outputs 32-bit unsigned integer from internal state.
      uint32 t0, t1;
      t0 = MTState.Status[3];
   #if defined(LINEARITY_CHECK)
      t1 = MTState.Status[0] ^ (MTState.Status[2] >> TinyMT32_SH8);
   #else
      t1 = MTState.Status[0] + (MTState.Status[2] >> TinyMT32_SH8);
   #endif
      t0 ^= t1;
      t0 ^= -((int32)(t1 & 1)) & MTState.TMat;
      return t0;
   }

   __inline void GetNextState()
   {
   // This function gets the next internal state of tinymt32.
      uint32 x;
      uint32 y;

      y = MTState.Status[3];
      x = (MTState.Status[0] & TinyMT32_Mask) ^ MTState.Status[1] ^ MTState.Status[2];
      x ^= (x << TinyMT32_SH0);
      y ^= (y >> TinyMT32_SH0) ^ x;
      MTState.Status[0] = MTState.Status[1];
      MTState.Status[1] = MTState.Status[2];
      MTState.Status[2] = x ^ (y << TinyMT32_SH1);
      MTState.Status[3] = y;
      MTState.Status[1] ^= -((int32)(y & 1)) & MTState.Mat1;
      MTState.Status[2] ^= -((int32)(y & 1)) & MTState.Mat2;
   }

   static uint32 Init1(uint32 x)
   {
      // This function represents a function used in the initialization by init_by_array
      return (x ^ (x >> 27)) * (uint32)1664525UL;
   }

   static uint32 Init2(uint32 x)
   {
      // This function represents a function used in the initialization by init_by_array
      return (x ^ (x >> 27)) * (uint32)1566083941UL;
   }
};
