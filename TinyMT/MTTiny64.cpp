/*
* @file TinyMT64.cpp - implements the Tiny Mersenne Twister.  Very fast quality rng.
*
* @brief Tiny Mersenne Twister only 127 bit internal state
*
* Original C code authors:
* @author Mutsuo Saito (Hiroshima University)
* @author Makoto Matsumoto (The University of Tokyo)
*
* VC++ cpp implementation by Bob Bryan on 4/23/2012:
* 1. Made the class retain state .vs. passing in the state each time a ran number is needed.
* 2. Added a method to fill an array with random bytes - see GetRandBytes().
* 3. Replaced globals with class vars.
* 4. Renamed methods, constants and types to something easier to remember.
* 5. Moved the private methods to the private section.
* 6. Cleaned up some comments.
* 7. Made the MT64State struct private.  Constructor now inits the object, but the Init method can
*    still be called to re-init the object to a different seed so that constant creating / deleting
*    of this object won't fragment memory.
* 8. Removed some methods:
*    1. PeriodCertification - was not doing anything useful.
*    2. Redundant floating point methods.
*    3. Conversion functions that the above methods call.
*    4. Init1 & Init2 - not being used in the 64 bit initialization methods.
*
* Copyright (C) 2011 Mutsuo Saito, Makoto Matsumoto,
* Hiroshima University and The University of Tokyo.
* All rights reserved.
*
* The 3-clause BSD License is applied to this software, see
* LICENSE.txt
*/

#include "MTTiny64.h"

double TinyMT64::TinyMT64_Mul = 1.0 / 18446744073709551616.0; // 1 / 2^64 - used to convert 64 bit int to a double float.

void TinyMT64::Init(uint64 Seed, uint32 Mat1, uint32 Mat2, uint64 TMat)
{
   // This function initializes the internal state array with a 64-bit unsigned integer seed.
   // The Mat1, Mat2, and TMat2 vars are also used as part of the seed.  These are generated by the DC
   // program.  256K of these values can be downloaded from this link:
   // http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/TINYMT/DATA/index.html
   // The tinymt64dc values should be used here, not the 32 bit values.
   // The code to generate these values can also be found on this website.
   //
   int i;
   MTState.Mat1 = Mat1;
   MTState.Mat2 = Mat2;
   MTState.TMat = TMat;
   MTState.Status[0] = Seed ^ ((uint64)Mat1 << 32);
   MTState.Status[1] = Mat2 ^ TMat;
   for (i = 1; i < MinLoop; i++)
   {
      MTState.Status[i & 1] ^= i + uint64(6364136223846793005) * (MTState.Status[(i - 1) & 1]
         ^ (MTState.Status[(i - 1) & 1] >> 62));
   }
}

void TinyMT64::InitByArray(uint32 Mat1, uint32 Mat2, uint64 TMat, const uint64 init_key[], int key_length)
{
   // This function initializes the internal state array with an array of 64-bit unsigned integers used as seeds.
   const int lag = 1;
   const int mid = 1;
   const int size = 4;
   int i, j;
   int count;
   uint64 r;
   uint64 st[4];
   //
   MTState.Mat1 = Mat1;
   st[1] = MTState.Status[1] = Mat1;
   MTState.Mat2 = Mat2;
   st[2] = MTState.Status[2] = Mat2;
   MTState.TMat = st[3] = MTState.Status[3] = TMat;
   st[0] = 0; // Seed is set to zero here.
   if (key_length + 1 > MinLoop)
   {
      count = key_length + 1;
   }
   else
   {
      count = MinLoop;
   }
   r = ini_func1(st[0] ^ st[mid % size] ^ st[(size - 1) % size]);
   st[mid % size] += r;
   r += key_length;
   st[(mid + lag) % size] += r;
   st[0] = r;
   count--;
   for (i = 1, j = 0; (j < count) && (j < key_length); j++)
   {
      r = ini_func1(st[i] ^ st[(i + mid) % size] ^ st[(i + size - 1) % size]);
      st[(i + mid) % size] += r;
      r += init_key[j] + i;
      st[(i + mid + lag) % size] += r;
      st[i] = r;
      i = (i + 1) % size;
   }
   for (; j < count; j++)
   {
      r = ini_func1(st[i] ^ st[(i + mid) % size] ^ st[(i + size - 1) % size]);
      st[(i + mid) % size] += r;
      r += i;
      st[(i + mid + lag) % size] += r;
      st[i] = r;
      i = (i + 1) % size;
   }
   for (j = 0; j < size; j++)
   {
      r = ini_func2(st[i] + st[(i + mid) % size] + st[(i + size - 1) % size]);
      st[(i + mid) % size] ^= r;
      r -= i;
      st[(i + mid + lag) % size] ^= r;
      st[i] = r;
      i = (i + 1) % size;
   }
   MTState.Status[0] = st[0] ^ st[1];
   MTState.Status[1] = st[2] ^ st[3];
}

void TinyMT64::GetRandBytes(void *pBytes, const int NumBytes)
{
   // This function obtains a specified number of random bytes and returns them into any array.
   // pBytes is a void pointer so any intrinsic type of array should work.
   int End = NumBytes / NumBytesInInt;
   int RemBytes = NumBytes % NumBytesInInt;
   int Loop;
   uint64 *p = (uint64 *)pBytes;
   uint64 RanNum;
   // Get the data 8 bytes at a time.
   for (Loop = 0; Loop < End; Loop++)
   {
      RanNum = GetRandInt();
      *p++ = RanNum;
   }
   if (RemBytes > 0)
   {
      // Get the last few remaining bytes when NumBytes is not an even multiple of 8.
      unsigned char *pBuf = (unsigned char *)p;
      unsigned char *pRand = (unsigned char *)&RanNum;
      RanNum = GetRandInt();
      for (Loop = 0; Loop < RemBytes; Loop++)
      {
         *pBuf++ = *pRand++;
      }
   }
}
