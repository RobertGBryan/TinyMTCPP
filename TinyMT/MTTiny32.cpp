/*
* @file TinyMT32.cpp - implements the Tiny Mersenne Twister.  Very fast quality rng.
*
* @brief Tiny Mersenne Twister only 127 bit internal state
*
* Original C code authors:
* @author Mutsuo Saito (Hiroshima University)
* @author Makoto Matsumoto (The University of Tokyo)
*
* VC++ cpp implementation by Bob Bryan on 4/23/2012:
* 1. Made the class retain state .vs. passing in the state each time a ran number is needed.
* 2. Added a method to fill an array with random bytes - see GetRandBytes().
* 3. Replaced globals with class vars.
* 4. Renamed methods, constants and types to something easier to remember.
* 5. Moved the private methods to the private section.
* 6. Cleaned up some comments.
* 7. Made the MT32State struct private.  Constructor now inits the object, but the Init method can
*    still be called to re-init the object to a different seed so that constant creating / deleting
*    of this object won't fragment memory.
* 8. Removed the following methods:
*    1. PeriodCertification - was not doing anything useful.
*    2. Redundant floating point methods.
*    3. Conversion functions that the above methods call.
*
* Copyright (C) 2011 Mutsuo Saito, Makoto Matsumoto,
* Hiroshima University and The University of Tokyo.
* All rights reserved.
*
* The 3-clause BSD License is applied to this software, see
* LICENSE.txt
*/

#include "MTTiny32.h"

double TinyMT32::TinyMT32_Mul = 1.0 / 4294967296.0; // 1 / 2^32 - used to convert 32 bit int to a float.

void TinyMT32::GetRandBytes(void *pBytes, const int NumBytes)
{
   // This function obtains a specified number of random bytes and returns them into any array.
   // pBytes is a void pointer so any intrinsic type of array should work.
   int End = NumBytes / NumBytesInInt;
   int RemBytes = NumBytes % NumBytesInInt;
   int Loop;
   uint32 *p = (uint32 *)pBytes;
   uint32 RanNum;
   // Get the data 4 bytes at a time.
   for (Loop = 0; Loop < End; Loop++)
   {
      RanNum = GetRandInt();
      *p++ = RanNum;
   }
   if (RemBytes > 0)
   {
      // Get the last few remaining bytes when NumBytes is not an even multiple of 4.
      unsigned char *pBuf = (unsigned char *)p;
      unsigned char *pRand = (unsigned char *)&RanNum;
      RanNum = GetRandInt();
      for (Loop = 0; Loop < RemBytes; Loop++)
      {
         *pBuf++ = *pRand++;
      }
   }
}

void TinyMT32::Init(uint32 Seed, uint32 Mat1, uint32 Mat2, uint32 TMat)
{
   // This function initializes the internal state array with a 32-bit unsigned integer seed.
   // The mat1, mat2, and tmat2 vars are also used as part of the seed.  These are generated by the DC
   // program.  256K of these values can be downloaded from this link:
   // http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/TINYMT/DATA/index.html
   // The tinymt32dc values should be used here, not the 64 bit values.
   // The code to generate these values can also be found on this website.
   // @param random tinymt state vector.
   // @param seed a 32-bit unsigned integer used as a seed.
   int i, n;
   MTState.Status[0] = Seed;
   MTState.Mat1 = MTState.Status[1] = Mat1;
   MTState.Mat2 = MTState.Status[2] = Mat2;
   MTState.TMat = MTState.Status[3] = TMat;
   for (i = 1; i < MinLoop; i++)
   {
      n = i + 1812433253 * (MTState.Status[(i - 1) & 3] ^ (MTState.Status[(i - 1) & 3] >> 30));
      MTState.Status[i & 3] ^= n;
   }
   for (i = 0; i < PreLoop; i++)
   {
      GetNextState();
   }
}

void TinyMT32::InitByArray(uint32 Mat1, uint32 Mat2, uint32 TMat, uint32 init_key[], int key_length)
{
   // This function initializes the internal state array with an array of 32-bit unsigned integers used as seeds.
   const int lag = 1;
   const int mid = 1;
   const int size = 4;
   int i, j;
   int count;
   uint32 r;
   uint32 * st = &MTState.Status[0];

   MTState.Mat1 = MTState.Status[1] = Mat1;
   MTState.Mat2 = MTState.Status[2] = Mat2;
   MTState.TMat = MTState.Status[3] = TMat;
   st[0] = 0; // Seed is set to zero here.
   if (key_length + 1 > MinLoop)
   {
      count = key_length + 1;
   }
   else
   {
      count = MinLoop;
   }
   r = Init1(st[0] ^ st[mid % size] ^ st[(size - 1) % size]);
   st[mid % size] += r;
   r += key_length;
   st[(mid + lag) % size] += r;
   st[0] = r;
   count--;
   for (i = 1, j = 0; (j < count) && (j < key_length); j++)
   {
      r = Init1(st[i] ^ st[(i + mid) % size] ^ st[(i + size - 1) % size]);
      st[(i + mid) % size] += r;
      r += init_key[j] + i;
      st[(i + mid + lag) % size] += r;
      st[i] = r;
      i = (i + 1) % size;
   }
   for (; j < count; j++)
   {
      r = Init1(st[i] ^ st[(i + mid) % size] ^ st[(i + size - 1) % size]);
      st[(i + mid) % size] += r;
      r += i;
      st[(i + mid + lag) % size] += r;
      st[i] = r;
      i = (i + 1) % size;
   }
   for (j = 0; j < size; j++)
   {
      r = Init2(st[i] + st[(i + mid) % size] + st[(i + size - 1) % size]);
      st[(i + mid) % size] ^= r;
      r -= i;
      st[(i + mid + lag) % size] ^= r;
      st[i] = r;
      i = (i + 1) % size;
   }
   for (i = 0; i < PreLoop; i++)
   {
      GetNextState();
   }
}
