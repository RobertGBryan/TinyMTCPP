#pragma once

// Typedefs used by this class:
typedef unsigned __int32 uint32;
typedef signed __int32 int32;
typedef unsigned __int64 uint64;
typedef signed __int64 int64;

class TinyMT64
{
   /*
   * @file tinymt64.h - implements the Tiny Mersenne Twister.  Very fast quality rng.
   * @brief Tiny Mersenne Twister - only 127 bit internal state
   * Original C code authors:
   * @OriginalAuthor Mutsuo Saito (Hiroshima University)
   * @OriginalAuthor Makoto Matsumoto (University of Tokyo)
   * Copyright (C) 2011 Mutsuo Saito, Makoto Matsumoto,
   * Hiroshima University and The University of Tokyo.
   * All rights reserved.
   *
   * VC++ cpp implementation by Bob Bryan on 4/23/2012:
   * 1. Made the class retain state .vs. passing in the state each time a ran number is needed.
   * 2. Added a method to fill an array with random bytes - see GetRandBytes().
   * 3. Replaced globals with class vars.
   * 4. Renamed methods, constants and types to something easier to remember.
   * 5. Moved the private methods to the private section.
   * 6. Cleaned up some comments.
   * 7. Made the MT64State struct private.  Constructor now inits the object, but the Init method can
   *    still be called to re-init the object to a different seed so that constant creating / deleting
   *    of this object won't fragment memory.
   * 8. Removed some methods:
   *    1. PeriodCertification - was not doing anything useful.
   *    2. Redundant floating point methods.
   *    3. Conversion functions that the above methods call.
   *    4. Init1 & Init2 - not being used in the 64 bit initialization methods.
   *
   * The 3-clause BSD License is applied to this software, see LICENSE.txt
   */
public:

   TinyMT64(uint64 Seed, uint32 Mat1, uint32 Mat2, uint64 TMat)
   {
      // Constructor - used to init the object.
      // Seed - used to seed the rng, best if obtained randomly.
      // Mat1, Mat2, & TMat are also used to seed the rng.  These values are generated by
      // the TinyMTDC utility app.  Only values generated from the 64 bit version of this program should be used.
      Init(Seed, Mat1, Mat2, TMat);
   }

   virtual ~TinyMT64(void) {}

   void Init(uint64 Seed, uint32 Mat1, uint32 Mat2, uint64 TMat);

   void InitByArray(uint32 Mat1, uint32 Mat2, uint64 TMat, const uint64 init_key[], int key_length);

   __inline uint64 GetRandInt()
   {
      // This function outputs 64-bit prng unsigned integer from the internal state.
      GetNextState();
      return GetNextRand();
   }

   void GetRandBytes(void *pBytes, int NumBytes);

   __inline double GetRandDouble()
   {
      // This function outputs a double floating point number from the internal state.
      // This function is implemented using multiplying by 1 / 2^64.
      // Floating point multiplication is faster than using union trick in my Intel CPU.
      // Return value is a double floating point number r where 0.0 <= r < 1.0.
      double d;
      GetNextState();
      d = GetNextRand() * TinyMT64_Mul;
      return d;
   }

private:

   static const int TinyMT64_MExp = 127;
   static const int TinyMT64_SH0 = 12;
   static const int TinyMT64_SH1 = 11;
   static const int TinyMT64_SH8 = 8;
   static const uint64 TinyMT64_Mask = 0x7fffffffffffffff;
   static const int MinLoop = 8;
   static const int PreLoop = 8;
   static const int NumBytesInInt = 8;
   static double TinyMT64_Mul;

   struct MT64State
   {
      //
      // Holds the internal state vector and parameters used by the rng.
      //
      uint64 Status[2];
      uint32 Mat1;
      uint32 Mat2;
      uint64 TMat;
   };

   MT64State MTState; // Holds the state.

   __inline uint64 GetNextRand()
   {
      // This function outputs a 64-bit unsigned integer from internal state.
       uint64 x;
   #if defined(LINEARITY_CHECK)
       x = MTState.Status[0] ^ MTState.Status[1];
   #else
       x = MTState.Status[0] + MTState.Status[1];
   #endif
       x ^= MTState.Status[0] >> TinyMT64_SH8;
       x ^= -((int64)(x & 1)) & MTState.TMat;
       return x;
   }

   __inline void GetNextState()
   {
   // This function gets the next internal state of TinyMT64.
       uint64 x;
       MTState.Status[0] &= TinyMT64_Mask;
       x = MTState.Status[0] ^ MTState.Status[1];
       x ^= x << TinyMT64_SH0;
       x ^= x >> 32;
       x ^= x << 32;
       x ^= x << TinyMT64_SH1;
       MTState.Status[0] = MTState.Status[1];
       MTState.Status[1] = x;
       MTState.Status[0] ^= -((int64)(x & 1)) & MTState.Mat1;
       MTState.Status[1] ^= -((int64)(x & 1)) & (((uint64)MTState.Mat2) << 32);
   }

   uint64 ini_func1(uint64 x)
   {
      // Used by the InitByArray method to init the rng.
      return (x ^ (x >> 59)) * uint64(2173292883993);
   }

   static uint64 ini_func2(uint64 x)
   {
      // Used by the InitByArray method to init the rng.
      return (x ^ (x >> 59)) * uint64(58885565329898161);
   }
};
